# Module Flattening Quick Start

## TL;DR

**Problem**: Blueprints like `#StatelessWorkload` are expensive to resolve at runtime (2-5 seconds per build).

**Solution**: "Compile" them away ahead of time into Units + Traits only.

**Result**: 50-80% faster builds, hermetic modules, no loss of safety.

---

## Three Layers Explained Simply

```cue
Author writes this (ModuleDefinition):
    components: {
        api: #StatelessWorkload & {
            statelessWorkload: {
                container: {image: "api:latest"}
                replicas: {count: 3}
            }
        }
    }

                    ⬇ FLATTEN (one-time, ~5-10s)

Compiled to this (Module IR):
    components: {
        api: {
            #units: {
                "opm.dev/units/workload@v1#Container": {
                    kind: "Unit"
                    schema: { ... fully inlined ... }
                }
            }
            #traits: {
                "opm.dev/traits/scaling@v1#Replicas": {
                    kind: "Trait"
                    schema: { ... fully inlined ... }
                }
            }
            // NO #StatelessWorkload Blueprint - it's been flattened!
        }
            container: {image: "api:latest"}
            replicas: {count: 3}
        }
    }

                    ⬇ BIND (add values, ~100ms)

Runtime uses this (ModuleRelease):
    #module: <reference to Module IR above>
    values: {api: {image: "api:v1.2.3", replicas: 3}}
```

---

## Why This Works

### Blueprints Are Sugar

- `#StatelessWorkload` = `Container` + `Replicas` + `HealthCheck` + ...
- Transformers only care about Units/Traits
- Blueprints exist for developer ergonomics, not runtime

### Flattening Is Compilation

- **Input**: High-level abstractions (Blueprints)
- **Output**: Low-level constructs (Units + Traits)
- **Analogy**: TypeScript → JavaScript, Kotlin → Java bytecode, etc.

### CUE References Are Fine

- The user clarified: CUE uses memory pointers internally
- Module (IR) can still have imports and references
- We're just removing Blueprints, not all structure

---

## Example: SimpleDatabase Flattening

### Before (ModuleDefinition)

```cue
database: {
    elements.#SimpleDatabase

    simpleDatabase: {
        engine: "postgres"
        version: "15"
        persistence: {enabled: true, size: "10Gi"}
    }
}
```

**What's hidden**:

- `#SimpleDatabase` composes `#StatefulWorkload`
- `#StatefulWorkload` composes `#Container`, `#RestartPolicy`, etc.
- Each layer adds conditional logic and merging

### After (Module IR)

```cue
database: {
    #units: {
        "opm.dev/units/workload@v1#Container": {
            kind: "Unit"
            schema: {
                name!: string
                image!: string
                ports?: [string]: {targetPort!: int}
                env?: [string]: {name!: string, value!: string}
                // ... full schema inlined
            }
            _provenance: {
                sourceBlueprint: "opm.dev/blueprints/data@v1#SimpleDatabase"
                viaBlueprint: "opm.dev/blueprints/workload@v1#StatefulWorkload"
            }
        }
        "opm.dev/units/storage@v1#Volume": {
            kind: "Unit"
            schema: {
                name!: string
                persistentClaim?: {
                    accessMode!: string
                    size!: string
                }
                // ... full schema inlined
            }
            _provenance: {sourceBlueprint: "opm.dev/blueprints/data@v1#SimpleDatabase"}
        }
    }
    #traits: {
        "opm.dev/traits/workload@v1#RestartPolicy": {
            kind: "Trait"
            schema: {policy: "Always" | "OnFailure" | "Never"}
            _provenance: {sourceBlueprint: "opm.dev/blueprints/data@v1#SimpleDatabase"}
        }
    }

    // Data (generated by Blueprint logic, but now static)
    container: {
        name: "database"
        image: "postgres:15"
        ports: db: {targetPort: 5432}
        env: {
            DB_NAME: {name: "DB_NAME", value: "blog"}
            // ...
        }
        volumeMounts: dbData: {name: "dbData", mountPath: "/var/lib/postgresql/data"}
    }

    restartPolicy: {policy: "Always"}

    volume: dbData: {
        name: "db-data"
        persistentClaim: {accessMode: "ReadWriteOnce", size: "10Gi"}
    }
}
```

**What changed**:

- ❌ `#SimpleDatabase` Blueprint removed
- ❌ `#StatefulWorkload` Blueprint removed
- ✅ Only Units (`Container`, `Volume`) and Traits (`RestartPolicy`) remain
- ✅ All schemas fully inlined (no lookups needed)
- ✅ Conditional logic already evaluated (static data)
- ✅ Provenance tracked (know where Units/Traits came from)

---

## Developer Workflow

### Authoring (No Change)

```bash
# Write ModuleDefinition with Blueprints
vim my-app-definition.cue

# Test locally (CLI flattens on-the-fly)
opm mod build my-app-definition.cue --output ./k8s

# Works exactly as before!
```

### Publishing (Optional Flatten)

```bash
# Option 1: Publish as-is (ModuleDefinition)
opm mod publish my-app-definition.cue --version v1.0.0

# Option 2: Flatten before publish (Module IR)
opm mod publish my-app-definition.cue --version v1.0.0 --flatten
# Now it's optimized for fast consumption
```

### Platform Team Workflow

```bash
# Curate platform catalog with pre-flattened modules
opm mod flatten vendor-app.cue --output modules/vendor-app-ir.cue

# Publish to platform registry
opm mod publish modules/vendor-app-ir.cue --version v1.0.0

# Now all users get fast builds!
```

---

## Performance Expectations

| Operation | Current | With Flattening | Improvement |
|-----------|---------|-----------------|-------------|
| **Flatten** (one-time) | N/A | 5-10s | N/A |
| **Build** (every time) | 2-5s | 0.5-1s | **50-80% faster** |
| **Memory** | High (full registry) | Low (only used Units/Traits) | 40-60% reduction |

---

## When to Flatten

### Always Flatten

- ✅ Publishing to platform catalog
- ✅ Distributing to external teams
- ✅ Production deployments
- ✅ CI/CD pipelines

### Optional Flatten

- ❓ Local development (CLI can do it on-the-fly)
- ❓ Personal projects

### Never Flatten

- ❌ Definition library source code (Units, Traits, Blueprints)
- ❌ Authoring templates
- ❌ When you want Blueprints visible for debugging

---

## Safety Guarantees

### What's Preserved

- ✅ All validation rules (CUE constraints)
- ✅ All metadata (labels, annotations)
- ✅ All data values
- ✅ All type safety

### What's Added

- ✅ Provenance metadata (origin Blueprint tracking)
- ✅ Content hashes (for version verification)
- ✅ Deterministic ordering (for diffing)

### What's Removed

- ❌ Blueprint definitions
- ❌ Intermediate abstraction layers
- ❌ Conditional composition logic (already evaluated)

---

## Analogy: TypeScript → JavaScript

| Concept | OPM Equivalent |
|---------|----------------|
| TypeScript (source) | ModuleDefinition with Blueprints |
| JavaScript (compiled) | Module IR with Units + Traits only |
| Type annotations | CUE constraints (preserved!) |
| Runtime | Transformer execution |
| Source maps | Provenance metadata |

Just like TypeScript compiles to JavaScript but keeps all type checking benefits during development, OPM flattens Blueprints but keeps all validation benefits in the IR.

---

## FAQ

### Q: Does flattening break type safety?

**A**: No! CUE constraints are preserved in the flattened output. The schemas are fully inlined, not removed.

### Q: Can I still use CUE imports?

**A**: Yes! Module (IR) is still valid CUE and can have imports. We're only removing Blueprints, not all references.

### Q: What if a Blueprint changes?

**A**: Re-flatten and bump version. Content hashing detects drift automatically.

### Q: Do I have to flatten everything?

**A**: No. CLI can detect ModuleDefinition vs Module (IR) and handle both. Flattening is an optimization, not a requirement.

### Q: How do I debug if Blueprints are gone?

**A**: Check provenance metadata in `_provenance` fields. They track which Blueprint added each Unit/Trait.

### Q: Is this a breaking change?

**A**: No. Fully backward compatible. CLI supports both ModuleDefinition and Module (IR).

---

## Next Actions

1. **Read**: [Full Implementation Plan](IMPLEMENTATION_PLAN.md)
2. **Spike**: Prototype Phase 1 (core flattening) in `cli/pkg/flatten`
3. **Test**: Use blog and supabase examples
4. **Iterate**: Refine based on learnings
5. **Ship**: Roll out to CLI and platform

---

## References

- [IMPLEMENTATION_PLAN.md](IMPLEMENTATION_PLAN.md) - Complete technical spec
- [core/CLAUDE.md](core/CLAUDE.md) - Core architecture context
- [cli/CLAUDE.md](cli/CLAUDE.md) - CLI architecture context
